### 1,2,3 더하기

- 정수 n을 1,2,3의 합으로 나타내는 방법의 수를 구하는 문제

- go(count,sum,goal)

- 숫자 count개로 합sum을 만드는 경우의 수

  1. 불가능한 경우(재귀 호출을 계속 해도 정답을 절대 찾을 수 없는 경우 | 문제의 조건을 위배한 경우) sum > goal

  2. 정답을 찾는 경우 sum == goal

  3. 다음 경우 호출

  go(count+1, sum+1, goal)
  
- 다만들고 나니 count변수는 필요가없다 ->  삭제
### 암호 만들기

- 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한개의 모음과 최소 두개의 자음으로 구성되어 있다

- 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되어있어야 한다

- 암호로 사용할 수 있는 문자의 종류는c가지

- 가능성 있는 암호를 모두 구하는 문제

- 3<=L<=C<=15

  0. (일단 모음1 자음2 조건빼고)

  1. 정답을 찾은 경우 (PASSWORD의길이 ==N) 

  2. 불가능한 경우

     i = ALPHA의 크기

  3. 다음 경우

     1. i 번째를 사용 : go(n, alpha,password+alpha[i],i+1)
     2.  i 번째를 사용안함: go(n,alpha, password,i+1)
### 퇴사(2^N)

- N+1일이 되는 날 퇴사를 하려고 한다

- 남은N일동안 최대한 많은 상담을 하려 한다

- 하루에 하나의 상담을 할 수 있고

- i일에 상담을 하면, T[i]일이 걸리고 P[i]원을 번다

  1. 정답을 찾은 경우

     day == n+1

  2. 불가능 한 경우

     day > n+1

  3. 다음 경우 호출

     1. 상담을 한다 : go(day+T[day] , sum+P[day])

     2. 상담을 하지 않는다

        go(day+1, sum) 

        

### 백트래킹

- 재귀 함수를 이용해 브루트 포스를 하다 보면, 더이상 함수호출이 의미 없는 경우가 있다
- 이 때, 이런 경우를 제외하고 브루트 포스를 진행하면 백트래킹이라고 한다

### 스타트와 링크(2^N)

- N명을 N/2명씩 두 팀으로 나누려고한다(4<=N<=20 , N은 짝수)
- 두 팀의 능력치를 구한 다음, 차이의 최소값을 구하는 문제
- S[i][j] = i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치
- 팀의 능력치 : 팀에 속한 모든 쌍의 S[i][j] 의 합

- 각각의 사람이 **1번팀 / 2 번팀** 에 들어가는경우

   - go(index, first, second)

     - index번째 사람을 어떤 팀에 넣을지 결정해야 함
     - 1번 팀과 2번 팀에 속한 사람이 각각 first, second에 들어있음

- 정답을 찾은 경우

  - index ==n

- 불가능한 경우

  - first 의 크기 > n/2
  - second 의 크기 > n/2

- 다음 경우

  - 1번 팀 :go(index, first,second)

  - 2번 팀:go(index, first,second)

  - 두 경우 모드 호출 전에 first 또는 second에 index를 넣고, 호출 후에 빼는 과정이 필요

    

 ### 부등호

- 부등호 기호 < 와 > 가 나열된 수열 A가 있다
- 기호의 앞 뒤에 한자리 숫자를 넣어서 모든 부등호 관계를 만족시키려고 한다
- 이때, 선택된 수는 모두 달라야 한다
- k개의 부등호 관계를 모두 만족시키는 (K+1) 개 자리의 정수 중에서 최대값과 최소값을 구하는 문제

  

