### 비트마스크

#### 비트연산  -  시간복잡도 O(1)

- & and
- | or
- ~ not
- ^ xor
- 

#### 수를 비트연산 할 때

- 두 수 A와 B를 비트 연산 하는 경우에는 가장 뒤의 자리부터 하나씩 연산을 수행하면 된다
- A = 27, B = 83인 경우
- A = 11011(2), B = 1010011(2)
- A & B = 19 , A | B = 91,  A ^ B = 72



- not 연산의 경우에는 자료형에 따라 결과가 달라진다
  - A = 83 = 1010011(2)
  - ~A = 10101100(2) (8비트 자료형인 경우)
  - ~A = 11111111 11111111 11111111 10101100(2) (32비트 자료형인 경우)
  - 또, unsigned, signed에 따라서 보여지는 값은 다르다
  - 

#### shift left 와 shift right 연산이 있다

- shift left (<<) 

  - 1 << 0 = 1
  - 1 <<  1 = 2 (10 (2))
  - 1 <<  2 = 4 (100 (2))
  - 1 <<  3 = 8 (1000 (2))
  - 1 <<  4  = 16 (10000 (2))
  - 3 <<  3 = 24 (11000(2))
  - 5 << 10 = 5120 (101000000000(2))

- shift right (>>)

  - 1 >> 0 = 1

  - 1 >> 1 = 0

  - 10 >> 1 = 5 (101(2)) 

  - 10 >> 2 = 2 (10(2))

  - 10 >> 3 = 1 (1(2))

    

### 비트마스크

- 정수로 집합을 나타낼 수 있다

- {1,3,4,5,9} = 570 = 2^1 + 2^3 + 2^4 + 2^5 + 2^9





###### 검사연산

{1,3,4,5,9} = 570

N개인경우 0 ~ (N-1)

- 0 이 포함되어있는지 검사
  - 0자리수를 1로 하고 & 연산 수행
- 1이 포함되어있는지 검사
  - 1자리 비트만 1로 하고 & 연산 수행



###### 추가연산

{1,3,4,5,9} = 570

- 1 추가하기
  - 570 | 2^1 = 570 | (1<<1) = 570 (1000111010(2)) 
  -  1번째 수를 1로 하고 | 연산 추가



###### 제거연산

나머지를 다 1로 만들고 제거하고싶은 비트만 0 을만든다

- 1제거하기

  - 570 & -2^1 = 570 & (1<<1) = 568 (1000111000(2))

    ​	1000111010

    &  1111111011

    -----------------------

    ​     1000110010



###### 토글연산 ( 0^1 = 1 ,  1^1 = 0)

토글 하고싶은 비트만 1 을만든다

- 1토글하기

  - 570 ^ -2^1 = 570 ^  (1<<1) = 568 (1000111000(2))

    ​	1000111010

    &  0000000100

    -----------------------

    ​     1000111110





## 부분 집합의 합 | 부분수열의 합

- 서로다른 N개의 정수로 이루어진 집합이 있을 때, 이 집합의 공집합이 아닌 부분집합 중에서 그 집합의 원소를 다 더한값이 s가 되는 경우의 수를 구하는 문제
- 모든 집합의 개수 = 2 ^N
- 모든 집합의 개수를 구하면 된다 !
- 공집합은 제외해야한다

```java
for (int i=1; 1<(1<<n); i++){
}    							//모든 부분수열을 만들었다
```



```java
for ( int i=1; i(1<<n); i++){    //집합 i를 만든다  //비트연산자 검사연산
	for(int k=0; k<n; k++){		// 각각의 k번째 수가 포함되어 있는지|아닌지 찾기
	if( i & (1<<k)){
	
		}
	}
}
```





## 스타트와 링크

- N명을 N/2명씩 두 팀으로 나누려고한다
- 두 팀의 능력치를 구한 다음, 차이의 최소값을 구하는 문제
- 각 사람을 두 팀 중 하나로 나누는 문제이기 때문에, 비트마스크를 이용할 수 있다
- 비트가 0 인 사람은 0 번팀, 1인 사람은 1번 팀이라고 하고
- 전체 경우의 수를 순회할 수 있다



## 종이 조각

- NxM 크기의 종이를 조각으로 잘라서 함의 최대값을 구하는 문제