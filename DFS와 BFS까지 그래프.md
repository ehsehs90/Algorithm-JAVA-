### DFS와 BFS까지 - 그래프

- 문제에 나와있는 상황을 그래프로 모델링 한 다음에, 여러가지 알고리즘들을 수행
- 알고리즘은 변하지 않고, 어떻게 문제의 상황를 그래프로 만드는지가 가장 중요



### 그래프

- 자료구조의 일정
- 정점(Node , Vertex)
- 간선 (Edge) : 정점과의 관계를 나타낸다
- G = (V , E) 로나타낸다.



### 경로

- 정점 A 에서 B로 가는 경로

![image-20191102235805394](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191102235805394.png)



- A > C > D > E > B
- A > C > E > B
- A > C > B
- A > B



### 사이클



![image-20191103000145246](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103000145246.png)

- 정점 A에서 다시 A로 돌아오는 경로
- A > C > B > A
- A > C > E > B > A
- A > C > D > E > B > A



### 단순 경로와 단순 사이클

- 경로 / 사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로, 사이클
- 특별한 말이 없으면 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말한다



### 방향 있는 그래프

- A > C 와 같이 간선에 방향이 있다
- A > C는 있지만, C > A 는 없다.



![image-20191103000426136](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103000426136.png)

### 방향 없는 그래프 

- A  - C와 같이 간선에 방향이 없다
- A - C 는 A > C 와  C > A를 나타낸다
- 양방향 그래프 라고도 한다
  - 방향이 없는 그래프는 양방향을 다 고려하기 때문이다 . 
  - 간선 2개로 나타낸다

![image-20191103000532164](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103000532164.png)



### 간선 여러개

- 두 정점 사이에 간선이 여러개 일 수도 있다

- 아래의 그림의 A - B 는 연결하는 간선이 2개이다

  -  최단거리 같은 경우 아래의 그림의 2개의 간선 중 큰 수는 지우고 생각한다.

- 두 간선은 서로 다른 간선이다 

  

![image-20191103000731813](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103000731813.png)



### 루프

- 간선의 양 끝점이 같은 경우
-  A > A



![image-20191103000905823](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103000905823.png)

### 가중치

- 간선에 써져 있는 어떤 값
- 간선의 가중치
- A에서 B로 이동하는 **거리**, 이동하는데 필요한 **시간**, 이동하는데 필요한 **비용** 등등..
- 가중치가 없는 경우 1이라고 생각하면 된다

![image-20191103001014002](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103001014002.png)





### 차수

- 정점과 연결되어 있는 간선의 개수
- 5 의 차수 3
- 4의 차수 4

![image-20191103001130822](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103001130822.png)

- 방향 그래프의 경우에는 In-dgree, Out-degree 로 나누어서 차수를 계산한다
- 4의 In-dgree : 3
- 4의 Out - dgree : 1



### 그래프의 표현 

	- 그래프의 표현 : 간선을 저장한다
	- 아래와 같은 그래프는 정점이 6개, 간선이 8개 있다

- 간선에 방향이 없기 때문에, 양방향 그래프 이다
- 정점 : {1,2,3,4,5,6}
- 간선:{(1,2),(1,5),(2,5),(2,4),(2,3),(3,4),(4,5),(4,6)}

![image-20191103002735227](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103002735227.png)



#### 그래프의 저장 방법

- 한 정점 X와 연결된 간선을 효율적으로 찾는 구조

1. 인접 행렬

2. 인접 리스트 
#### 인접 행렬

- 정점의 개수를 V라고 했을 때
- V x V 크기의 이차원 배열을 사용한다
- A(i)(j) = 1 ( i-> j 간선이 있을 때), 0 (없을 때)
- A(i)(j) = w ( i-> j 간선이 있을 때 그 가중치), 0 (없을 때)

![image-20191103003555582](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103003555582.png)

- 정점 V, 간선  E 인경우 필요한 인접행렬의 공간은 ? V ^2
- 한 정점에 연결된 모든 간선을 구하는데 걸리는 시간 :  O(V)



#### 인접 리스트

- 리스트를 이용해서 구현한다 - 몇 개가 있을지 알 수 없기 때문에 리스트로 구현

- A[i]  = i 와 연결된 정점을 리스트로 포함하고 있음

- A[i]  = i 와 연결된 정점과 그 간선의 가중치를 리스트로 포함하고 있음

- 리스트는 크기를 동적으로 변경할 수 있어야 한다

- 링크드 리스트나 길이를 동적으로 변경할 수 있는 배열을 사용한다

  - (c++ : vector , java : arraylist , python : [리스트])

  - 공간 복잡도 

    - 인접 행렬 : O(V^2)
    - 인접 리스트 : O(E) : 간선이 있는 것만 저장하기 때문

  - 한 정점과 연결된 모든 간선을 찾는 시간 

    - 인접 행렬 :
    - 인접 리스트 : O(차수)
      - *따라서 인접 리스트가 인접 행렬보다 더 적게 ,작게 소요된다.*
      - 따라서 대부분의 경우 인접 리스트가 더 좋다
      - 예외) (U,V) 간선 있는지 없는지 ?
        - 인접 행렬 : O(1)
        - 인접 리스트 O(차수)

    

![image-20191103004020529](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103004020529.png)

- 가중치가 있는 경우

  

![image-20191103004141691](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103004141691.png)

#### 간선 리스트

- 배열을 이용해서 구현한다
- 간선을 모두 저장하고 있다

![image-20191103004936287](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103004936287.png)

  - E 라는 1차원 배열에 간선을 다 넣어주고, 앞의 정점을 기준으로 정렬한다

    앞의 정점이 몇개인지를 cnt라는 배열에 저장한다

- 앞 정점과 그 옆에 있는 정점의 합을 누적해서 구한다

- ![image-20191103005246571](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103005246571.png)

- 간선리스트는 잘 사용하지 않음 -
  
  - 써야하는 경우 : 인접리스트를 써야하는데 라이브러리 사용이 금지된 경우





## 연습문제

#### ABCDE

- 총 N명의 친구 관계가 주어졌을 때
- 다음과 같은 친구 관계가 존재하는지 구하는 문제
- A와 B는 친구다
- B는 C와 친구다
- C는 D와 친구다
- D는 E와 친구다

[풀이]

친구관계 - 간선 | 친구 - 정점

![image-20191103005758087](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103005758087.png)

a배열 :  인접 행렬

g배열 : 인접 리스트

edge : 간선 리스트





# 그래프의 탐색

1. DFS : 깊이 우선 탐색
2. BFS : 너비 우선 탐색

- 공통 - 목적 : 임의의 정점에서 시작해서 연결되어있는 모든 정점을 1번씩 방문하는 것
- 차이 - 어떤 순서로 정점을 방문할 것인가



### 깊이 우선 탐색(DFS)

- 스택을 이용해서 갈 수 있는 만큼 최대한 많이 가고
- 갈 수 없으면 이전 정점으로 돌아간다
  - check : 어떤 정점을 방문 했는지 안했는지 구분하는 배열

![image-20191103011513494](C:\Users\82109\eclipse-workspace\CodePlus\DFS와 BFS까지 그래프.assets\image-20191103011513494.png)

- 5에서 더 갈 수 있는 것이 없기 때문에, 4로 돌아간다

  ( 1 2 3 4 5)

- stack -1

- 4로 돌아온 후, 안간 정점을 찾는다 : 6으로 이동 

  - 순서 1 2 3 4 5 6
  - 스텍 1 2 3 4 6

- 정점 한번씩 찍기 완료 

  - 이제 6에서 갈 게 없으니 stack -1 (1 2 3 4 )
  - 4에서 갈 게 없으니 stack -1 (1 2 3 )
  - 3에서 갈 게 없으니 stack -1 (1 2 )
  - 2에서 갈 게 없으니 stack -1 (1 )
  - 1에서 갈 게 없으니 stack -1 ()
  - 탐색 종료

- 재귀 호출을 이용해서 구현할 수 있다 - 인접 행렬을 이용한 구현

- 시간 복잡도  O(V^2) : 모든 정점을 다 살펴봐야 하므로 (VxO(V))

- ```java
  void dfs(index x){
      check[x] = true; 							//x방문
      for(int i=1; i<=n; i++){
          if (a[x][i] ==1 && check[1] == false){	//어딜 갈 수 있나?
              								//(한 정점과 연결되어 있는 모든 정점)
              									//간선이 있고 방문한적이 없을 때
              dfs(i);
      	}
  	}
  }
  ```

- 인접 리스트를 이용한 구현

- 시간복잡도 O(VxE)

  ```java
  void dfs(int x){
     check[x] = true;
      for(int i=0 i<a[x].size(); i++) //인접리스트는 X라는 곳에 X와 연결되어있는 모든 정									  //점이 연결되어 있으므로
          int y = a[x][i];
      if(check[y] == false){
          dfs(y);
      }
  }
  ```

  



### 너비 우선 탐색(Breadth First Search) **

- 큐를 이용해서 지금 위치에서 갈 수 있는 것들을 모두 큐에 넣는 방식
- 큐에 넣을 때 방문했다고 체크해야 한다.

```java
// BFS 의 구현은 큐를 이용해서 할 수 있다(인접 행렬)
queue<int> q;
check[1] = true; q.push(1);  //시작점
while (q.empty()){
    int x = q.front(); q.pop();  //현재점
    for (int i=1; i<=n, i++){
        if(a[x][i] == 1 && check[i] ==false ){
            check[i] =true;  //q에 넣을 때 방문했다고 처리
            q.push(i);
        }
    }
}
```

